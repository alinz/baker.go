package baker

import (
	"encoding/json"
	"fmt"
	"net"
	"strings"
)

// ContainerType defines which watcher produce them
type ContainerType string

const (
	// DockerContainer defines by docker driver
	DockerContainer ContainerType = "docker"
)

// Container is piece of object which contains information
// about each Node or Container
type Container struct {
	// Unique ID generated by container orcestration
	ID string
	// Type shows what type of container it is
	Type ContainerType
	// Active show wheather container is added or removed
	Active bool
	// RemoteAddr is IP:PORT which container is listening to
	RemoteAddr net.Addr
	// ConfigPath is the path to extract config data
	ConfigPath string
	// Err if error detected by orcestration system, it pass it here. In most case it means that Container is dead
	Err error
}

func (c Container) String() string {
	return fmt.Sprintf("ID: %s, Type: %s, Active: %t, Addr: %s, ConfigPath: %s, Err: %s", c.ID, string(c.Type), c.Active, c.RemoteAddr, c.ConfigPath, c.Err)
}

type Recipe struct {
	Name   string          `json:"name"`
	Config json.RawMessage `json:"config"`
}

// Rule contains basic information about
// domain, path and availability of each container
type Rule struct {
	Domain  string    `json:"domain"`
	Path    string    `json:"path"`
	Ready   bool      `json:"ready"`
	Recipes []*Recipe `json:"recipes"`
}

func (r Rule) String() string {
	return fmt.Sprintf("Domain: %s, Path: %s, Ready: %t", r.Domain, r.Path, r.Ready)
}

// Rules a wrapper around array of Rule to make it simpler to work with
// array of rules
type Rules []*Rule

// Each loop through each rule and call given func
func (r Rules) Each(fn func(r *Rule)) {
	for _, rule := range r {
		fn(rule)
	}
}

// Service is a set of configuration that points to a specific running container
// Each container can have multiple services linked to them
type Service struct {
	Rule      *Rule
	Container *Container
}

func (s Service) String() string {
	builder := strings.Builder{}

	if s.Rule != nil {
		builder.WriteString("Rule:\n")
		builder.WriteByte('\t')
		builder.WriteString(s.Rule.String())
		builder.WriteByte('\n')
	}

	builder.WriteString("Container:\n")
	builder.WriteByte('\t')
	builder.WriteString(s.Container.String())

	return builder.String()
}

type Services struct {
	collection []*Service
}

func (s *Services) Add(service *Service) {
	s.collection = append(s.collection, service)
}

func (s *Services) Clean() {
	s.collection = make([]*Service, 0)
}

func (s *Services) Each(fn func(service *Service, i int)) {
	for i, service := range s.collection {
		fn(service, i)
	}
}

func NewServices() *Services {
	return &Services{
		collection: make([]*Service, 0),
	}
}

// Watcher defines how driver should react
type Watcher interface {
	// Container gets the next available container
	// this is a blocking calls, if Container object is nil
	// it means that Watcher has been closed
	Container() (*Container, error)
}

// Pinger defines how container can be ping to get extra information
// and construct Service object
type Pinger interface {
	// Service if service returns an nil value, it means that Pinger has
	// some internal error and it will no longer return service
	Service() (*Service, error)
}

// Store will be used ti get Container
type Store interface {
	// Query returns a service based on domain and path
	Query(domain, path string) *Service
}
