package baker

import (
	"github.com/alinz/baker.go/internal/addr"
	"github.com/alinz/baker.go/internal/balance"
	"github.com/alinz/baker.go/internal/errors"
	"github.com/alinz/baker.go/internal/rule"
	"github.com/alinz/baker.go/internal/store"
	"github.com/alinz/baker.go/internal/store/trie"
)

const (
	ErrDomainNotFound        = errors.Value("domain not found")
	ErrPathNotFound          = errors.Value("path not found")
	ErrServiceNotInitialized = errors.Value("service not initialized")
	ErrTargetNotFound        = errors.Value("target not found")
)

// Config is a configuration which can be sent by service
type Config struct {
	Domain       string        `json:"domain"` // could be example.com. www.example.com, api.example.com
	Path         string        `json:"path"`   // could be /v1/system, /v1/system*
	Ready        bool          `json:"ready"`
	RuleHandlers rule.Handlers `json:"rule_handlers"`
}

// Container is piece of object which contains information
// about Container
type Container struct {
	ID         string        // Unique ID generated by container orcestration
	Active     bool          // Active show wwheather container is added or removed
	RemoteAddr addr.Endpoint // RemoteAddr is IP:PORT which container is listening to
	ConfigPath string        // ConfigPath is the path to extract config data
	Err        error         // Err if error detected by orcestration system, it pass it here
	//////////////////// Usually it means that Container is dead
}

// Target is a wrapper for both container and config
type Target struct {
	Container *Container
	Config    *Config
}

// Service struct
type Service struct {
	targets map[string]*Target
	balance balance.Balancer
}

// Add creates target object based on container and config and
// adds it into Service's targets map.
func (s *Service) Add(container *Container, config *Config) error {
	target, ok := s.targets[container.ID]
	if ok {
		return errors.Value("contaner with " + container.ID + " already exists")
	}

	target = &Target{
		Container: container,
		Config:    config,
	}

	err := s.balance.Add(container.ID)
	if err != nil {
		return err
	}

	s.targets[container.ID] = target
	return nil
}

// Get returns a Target based on balancer strategy.
// Currently, round-robin is being used
// Refer to internal/balanc package
func (s *Service) Get() (*Target, error) {
	id, err := s.balance.Get()
	if err != nil {
		return nil, err
	}

	target, ok := s.targets[id]
	if !ok {
		return nil, ErrTargetNotFound
	}

	return target, nil
}

// Remove removes container id from service
func (s *Service) Remove(containerID string) error {
	_, ok := s.targets[containerID]
	if !ok {
		return ErrTargetNotFound
	}

	// remove the Container config
	delete(s.targets, containerID)

	// remove container
	return s.balance.Del(containerID)
}

// newService creates an empty service
func newService() *Service {
	return &Service{
		targets: make(map[string]*Target),
		balance: balance.NewRoundRobin(),
	}
}

// Domain is a single unit which contains all the paths
type Domain struct {
	// paths is Key Value store which
	// Key is Path and Value is Service object
	// <Path, Service>
	paths store.KeyValue
}

// newDomain creates a new empty domain object which has trie key value
func newDomain() *Domain {
	return &Domain{
		paths: trie.New(true),
	}
}

// Add inserts/updates path for given container
func (d *Domain) Add(container *Container, config *Config) error {
	var service *Service

	key := []rune(config.Path)

	if value, err := d.paths.Get(key); err == nil {
		service = value.(*Service)
	} else if err == store.ErrItemNotFound {
		service = newService()
		err = d.paths.Put(key, service)
		if err != nil {
			return err
		}
	}

	return service.Add(container, config)
}

// Get gets any service base on matching path
// the matching path is based on trie
func (d *Domain) Get(path string) (*Service, error) {
	value, err := d.paths.Get([]rune(path))
	if err == store.ErrItemNotFound {
		return nil, ErrPathNotFound
	}

	service, ok := value.(*Service)
	if !ok {
		// This shouldn't happen. if happens, something went seriously wrong
		return nil, ErrServiceNotInitialized
	}

	return service, nil
}

// Remove service from domain
func (d *Domain) Remove(containerID string, path string) error {
	key := []rune(path)

	value, err := d.paths.Get(key)
	if err != nil {
		return err
	}

	service, ok := value.(*Service)
	if !ok {
		return ErrServiceNotInitialized
	}

	return service.Remove(containerID)
}

// Store is contains all registered domains
type Store struct {
	// domains holds Domain object
	// Key is domain name and value is Domain object
	// <Example.com, Domain>
	domains map[string]*Domain
	// configs is a map of container id to array of configs
	// it means that, each container can serve more than one config
	configs map[string][]*Config
}

// Add starts the chain of adding a new container
func (s *Store) Add(container *Container, config *Config) error {
	domain, ok := s.domains[config.Domain]
	if !ok {
		domain = newDomain()
		s.domains[config.Domain] = domain
	}

	err := domain.Add(container, config)
	if err != nil {
		return err
	}

	configs, ok := s.configs[container.ID]
	if !ok {
		configs = make([]*Config, 0)
	}
	s.configs[container.ID] = append(configs, config)

	return nil
}

// Get gets domain object. ErrDomainNotFound is otherwise
func (s *Store) Get(domain string) (*Domain, error) {
	val, ok := s.domains[domain]
	if !ok {
		return nil, ErrDomainNotFound
	}
	return val, nil
}

// Remove container in tree
func (s *Store) Remove(container *Container) error {
	configs, ok := s.configs[container.ID]
	if !ok {
		return nil
	}

	delete(s.configs, container.ID)

	for _, config := range configs {
		domain, err := s.Get(config.Domain)
		if err != nil {
			return err
		}

		err = domain.Remove(container.ID, config.Path)
		if err != nil {
			return err
		}
	}

	return nil
}

// NewStore creates new Store
func NewStore() *Store {
	return &Store{
		domains: make(map[string]*Domain),
		configs: make(map[string][]*Config),
	}
}
